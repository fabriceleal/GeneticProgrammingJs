<html>
	<head>		
		<script src="vendors/kinetic-v4.0.1.min.js"></script>
		<script src="vendors/jquery-1.8.1.min.js"></script>
		<script src="vendors/stats.js"></script>
		<script>
			$(function(){
				var worker;
				// kinetic
				var stage, layer, anim;
				var stats;
				
				var selected;
				var SCALE = 30;
				
				var selectedInfo = $('#selected-info');
				
				$('#profile-start').click(function(){ console.profile('Profile ...'); });
				$('#profile-stop').click(function(){ console.profileEnd(); });
				
				stats = new Stats();					
				$('#stats')[0].appendChild(stats.domElement);
				
				stage = new Kinetic.Stage({
					container: "canvas-world",
					width: 900,
					height: 600
				});
				layer = new Kinetic.Layer();

				(function(){
					var background = new Kinetic.Rect({
						x: 0,
						y: 0,
						width: stage.getWidth(),
						height: stage.getHeight(),
						fill: "black",
					});					
					layer.add(background);
				})();
				
				layer.on('mousedown', function(evt){
					selectedInfo.html('');
				});

				var entities = {};				
				/*for(var i = 1; i < 50; ++i){
					entities['circle' + i] = { 
						type:'circle', 
						radius:2 / SCALE, 
						x: Math.random() * 450 / SCALE, 
						y: Math.random() * 300 / SCALE, 
						angle:0, 
						id: 'circle' + i};				
				}*/
				for(var i = 1; i < 50; ++i){
					entities['triangle' + i] = {
						type:'polygon',
						color: i % 2 ? 'blue' : 'red',
						points:[{x: 0 / SCALE, y: 0 / SCALE}, {x: 10 / SCALE, y: 0 / SCALE}, {x: 0 / SCALE, y: 15 / SCALE}],
						x: Math.random() * 450 / SCALE,
						y: Math.random() * 300 / SCALE,
						angle: 0,
						id: 'triangle' + i
					};
				}
				
				/*
				var unrolledUpdate = '';
				for(var id in entities){
					unrolledUpdate += "current = data['" + id + "'];\n";
					unrolledUpdate += "entity = entities['" + id + "'];\n";
					unrolledUpdate += "entity.x = current.x;\n";
					unrolledUpdate += "entity.y = current.y;\n";
				}
				
				var updateAll = eval('(function(){ return function(data, entities){var current, entity;\n' + unrolledUpdate + ' } })()')
				
				delete unrolledUpdate;
				*/
				worker = new Worker('exec2.js');
				worker.addEventListener('error', function(e){
					console.warn('Error!');
					console.error(e);
				});
				worker.addEventListener('message', function(event){						
					var data = event.data;
					var __name = data.name;
					var __data = data.data;
					var __err = data.err;
					
					if(__err){
						console.log('ERROR:', data);
						return;
					}
					
					if(__name === 'update') {
						var current, entity;
						
						// FIXME: Unroll this.						
						for(var id in __data){
							current = __data[id];
							entity = entities[id];
							
							entity.x = current.x;
							entity.y = current.y;
							entity.angle = current.a;
						}
						
						//eval(unrolledUpdate);
						
						//updateAll(__data, entities);
					}

					if(__name === 'create'){
						try{
							worker.postMessage({name:'appendBodies', data:entities } );
						}catch(e){
							console.warn('Error append bodies to world. Check the entities object: ');
							console.log(JSON.stringify(entities));
							console.error(e);
						}
					}

					if(__name === 'appendBodies'){
						worker.postMessage({name:'start', data:entities} );
					}
					
					if(__name === 'start'){
						// After appending, attach the drawing function ... which also creates the visual
						// representations ...
						for(var k in entities){
							(function(entity){
							
								entity.draw = (function(_this){
									var obj; 
									var lastAngle = _this.angle;
									var lastX = _this.x;
									var lastY = _this.y;
									
									if(_this.type === 'circle'){
										obj = new Kinetic.Circle({
											radius: _this.radius * SCALE,
											fill: "red",
											stroke: "yellow",
											strokeWidth: 2,
											x: _this.x * SCALE,
											y: _this.y * SCALE
										});
									} else if(_this.type === 'polygon'){
										obj = new Kinetic.Polygon({
											points: entity.points.map(function(e){ return [e.x * SCALE, e.y * SCALE]; }).reduce(function(t, i){ return t.concat(i)},[]),
											fill: _this.color, //"red",
											//stroke: "yellow",
											//strokeWidth: 2,
											x: _this.x * SCALE,
											y: _this.y * SCALE
										});
									}
									
									if(! obj)
										throw 'No object!';

									obj.on('mousedown', function(evt){
										// Select!
										selected = obj;
										// Cancel from propagating upwards
										evt.cancelBubble = true;
										
										selectedInfo.html(
												'Selected is ' + _this.id + ', <br/ > here: ' + obj.getX() + ', ' + obj.getY() + 
												'<br/><a id="force" href="#">Apply force!</a><br/ ><a id="impulse" href="#">Apply impulse!</a>');
										
										$('#force').click(function(){
											worker.postMessage({name: "applyForce", data: { id: _this.id, degrees: (Math.random()*360 - 180), power: 1}});
										})
										$('#impulse').click(function(){
											worker.postMessage({name: "applyImpulse", data: { id: _this.id, degrees: (Math.random()*360 - 180), power: 1}});
										})
									});
																		
									layer.add(obj);
									obj.moveToTop();
									
									return function(){
										if(_this.x != lastX) {
											obj.setX(_this.x * SCALE);
											lastX = _this.x;
										}
										if(_this.y != lastY) {
											obj.setY(_this.y * SCALE);
											lastY = _this.y;
										}
										if(_this.angle != lastAngle){
											obj.rotate( _this.angle - lastAngle );
											lastAngle = _this.angle;
										}
									}
								})(entity);
								
							})(entities[k]);
						}
																		
						stage.add(layer);
						
						// Start drawing!
						anim = new Kinetic.Animation({
						  func: (function(){
									var ready = true;
									return function(frame) {
										if(ready){
											ready = false;

											// Draw all entities ...
											// FIXME: Unroll this.
											for(var k in entities) {
												entities[k].draw();
											}

											stats.update();

											ready = true;
										}
									};
								})(),
						  node: layer
						});
						anim.start();
					}
					
					if(__name === 'debug'){
						console.log(__data);
					}
				
				}); // worker.addEventListener(function(event){ ...
				
				// Ready to start ...
				$('#starter').click(function(){ 
					worker.postMessage({name:'create', data:{ scale: SCALE, width: 900 /*stage.GetWidth()*/, height: 600 /*stage.getHeight()*/ }}); 
					
					// Remove onClick to starter...
					$('#starter').click(function(){ });
					 					
					// Add onClick to stopper
					$('#stopper').click(function(){
						anim.stop();
						worker.postMessage({name:'close'});
					});
				});
				
			}); // $(function(){ ...
			
			
		</script>
	</head>
	<body>
		May work better on chrome ...<br/ >
		<a id='starter' href="#">Start!</a>
		<a id='stopper' href="#">Stop!</a><br />
		<a id='profile-start' href='#'>Start profile</a>
		<a id='profile-stop' href='#'>Stop profile</a>
		<div id="stats"></div>
		<div id="canvas-world" style="float: left;"></div>
		<div id="selected-info" style="float: left;"></div>
	</body>
</html>